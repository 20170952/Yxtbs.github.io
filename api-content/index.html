{"posts":[{"title":"CF1555场题解","content":"Educational Codeforces Round 112 (Rated for Div. 2) A.PizzaForces Difficulty\\mathtt{Difficulty}Difficulty=900\\mathtt{900}900 首先我们来枚举一下，得知：666 及以上的偶数都会刚好分完 而且每个披萨的性价比是一样的 那么，我们可以这样考虑： 如果人数不多于 666 人，那么也要 151515 分钟 如果人数多于 666 人且为偶数，那么肯定可以刚好吃完，没有多余 如果人数多于 666 人且为奇数，那么一定会剩下一个人的量 然后就不难写出代码了 #include&lt;bits/stdc++.h&gt; using namespace std; #define int long long signed main(void) { register int Case;cin&gt;&gt;Case;while(Case--) { register int N;cin&gt;&gt;N; if(N&lt;=6)cout&lt;&lt;15&lt;&lt;endl; else if(N&amp;1)cout&lt;&lt;(N+1)/2*5&lt;&lt;endl; else cout&lt;&lt;N/2*5&lt;&lt;endl; } return 0; } B.Two Tables Difficulty\\mathtt{Difficulty}Difficulty=1300\\mathtt{1300}1300 肯定是横着平移或者竖着平移才有可能作为最短距离 不难发现，我们一定只能把它移到边界上 那么我们不妨枚举 444 条边，然后依次判是否可行 最后再取一下答案即可 然后就不难写出代码了 #include&lt;bits/stdc++.h&gt; using namespace std; int N,M,A,B,C,D,E,F,P,Q; signed main(void) { register int Case;cin&gt;&gt;Case;while(Case--) { cin&gt;&gt;N&gt;&gt;M&gt;&gt;A&gt;&gt;B&gt;&gt;C&gt;&gt;D&gt;&gt;E&gt;&gt;F; register int Ans=1000000000; P=abs(A-C),Q=abs(B-D); if(P+E&lt;=N)Ans=min(Ans,min(max(0,E-N+max(A,C)),max(0,E-min(A,C)))); if(Q+F&lt;=M)Ans=min(Ans,min(max(0,F-M+max(B,D)),max(0,F-min(B,D)))); if(Ans&gt;=99999999)cout&lt;&lt;-1&lt;&lt;endl; else cout&lt;&lt;Ans&lt;&lt;&quot;.000000&quot;&lt;&lt;endl; } return 0; } C.Coin Rows Difficulty\\mathtt{Difficulty}Difficulty=1300\\mathtt{1300}1300 看懂题目之后，我们来观察样例 我们提出一个猜想：Bob 只能先一直往右，再一直往下或是先一直往下，再一直往右 然后我们考虑分别用前缀和维护一下，不然会 TLE\\texttt{TLE}TLE 维护完之后，暴力枚举 Alice 的路线即可 然后就不难写出代码了 #include&lt;bits/stdc++.h&gt; using namespace std; #define int long long int N; int Dp1[100001],Dp2[100001]; signed main(void) { register int Case;cin&gt;&gt;Case;while(Case--) { register int i;cin&gt;&gt;N; for(i=1;i&lt;=N;i++)Dp1[i]=Dp2[i]=0; for(i=1;i&lt;=N;i++){register int X;cin&gt;&gt;X;Dp1[i]=Dp1[i-1]+X;} for(i=1;i&lt;=N;i++){register int X;cin&gt;&gt;X;Dp2[i]=Dp2[i-1]+X;} register int Ans; Ans=min(Dp1[N]-Dp1[1],Dp2[N-1]); for(i=2;i&lt;N;i++)Ans=min(Ans,max(Dp1[N]-Dp1[i],Dp2[i-1])); if(N==1)Ans=0; cout&lt;&lt;Ans&lt;&lt;endl; } return 0; } D.Say No to Palindromes Difficulty\\mathtt{Difficulty}Difficulty=1600\\mathtt{1600}1600 这道题放在第四道，差评！ 实际上，看懂题目之后，我们不难想到一个结论： 该字符串一定是 a,b,ca,b,ca,b,c 的一个排列不断重复 然后我们干脆暴力枚举 666 种情况，但是我们会发现自己 TLE\\texttt{TLE}TLE 了 于是我们考虑加上一个前缀和维护，然后差分一把答案即可 然后就不难写出代码了 #include&lt;bits/stdc++.h&gt; using namespace std; int N,M; string S,S0[7]={&quot;&quot;,&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;}; int Prefix[7][200011]; int main(void) { register int i,j;cin&gt;&gt;N&gt;&gt;M;cin&gt;&gt;S;S=&quot;@&quot;+S; for(i=1;i&lt;=6;i++) { for(j=1;j&lt;=N;j++)if(S0[i][(j-1)%3]!=S[j])Prefix[i][j]=Prefix[i][j-1]+1; else Prefix[i][j]=Prefix[i][j-1]; } while(M--) { register int Left,Right;cin&gt;&gt;Left&gt;&gt;Right; register int Ans=Right-Left+1; for(i=1;i&lt;=6;i++)Ans=min(Ans,Prefix[i][Right]-Prefix[i][Left-1]); cout&lt;&lt;Ans&lt;&lt;endl; } return 0; } E.Boring Segments Difficulty\\mathtt{Difficulty}Difficulty=2100\\mathtt{2100}2100 题意是最小化最大值和最小值的差，不难想到 two-pointer\\texttt{two-pointer}two-pointer 枚举左端点，然后把上次的右端点继续向右移动即可 我们不妨使用线段树来维护这个区间 插入、删除就是在线段树 [l,r−1][l,r-1][l,r−1] 上加减，维护区间 时间复杂度 O(nlogm)\\mathcal{O(nlogm)}O(nlogm)，想必是正解吧 #include&lt;bits/stdc++.h&gt; using namespace std; struct Struct { int Left,Right,Value; inline bool operator &lt;(const Struct &amp;Compare)const { return Value&lt;Compare.Value; } }; struct Node { int Tmp,Tag; }; int N,M; Struct S[1000010]; Node C[4000040]; inline void Pd(int Rt) { if(C[Rt].Tag) { C[Rt*2].Tag+=C[Rt].Tag; C[Rt*2+1].Tag+=C[Rt].Tag; C[Rt*2].Tmp+=C[Rt].Tag; C[Rt*2+1].Tmp+=C[Rt].Tag; } C[Rt].Tag=0; } inline void Pu(int Rt) { C[Rt].Tmp=min(C[Rt*2].Tmp,C[Rt*2+1].Tmp); } inline void Add(int Rt,int L,int R,int LL,int RR,int VV) { if(L&gt;=LL&amp;&amp;R&lt;=RR){C[Rt].Tag+=VV,C[Rt].Tmp+=VV;return;} Pd(Rt); if((L+R&gt;&gt;1)&gt;=LL)Add(Rt*2,L,(L+R&gt;&gt;1),LL,RR,VV); if((L+R&gt;&gt;1)&lt;RR)Add(Rt*2+1,(L+R&gt;&gt;1)+1,R,LL,RR,VV); Pu(Rt); } int main(void) { register int i,Cnt=0,Ans=INT_MAX,T=0; cin&gt;&gt;N&gt;&gt;M,M--; for(i=1;i&lt;=N;i++)cin&gt;&gt;S[i].Left&gt;&gt;S[i].Right&gt;&gt;S[i].Value,S[i].Right--; sort(S+1,S+N+1); while(!C[1].Tmp)Cnt++,Add(1,1,M,S[Cnt].Left,S[Cnt].Right,1); Add(1,1,M,S[Cnt].Left,S[Cnt].Right,-1); for(i=Cnt;i&lt;=N;i++) { Add(1,1,M,S[i].Left,S[i].Right,1); while(C[1].Tmp)T++,Add(1,1,M,S[T].Left,S[T].Right,-1); Add(1,1,M,S[T].Left,S[T].Right,1); Ans=min(Ans,S[i].Value-S[T].Value),T--; } cout&lt;&lt;Ans&lt;&lt;endl; return 0; } ","link":"https://20170952.github.io/Yxtbs.github.io/post/cf1555-chang-ti-jie/"},{"title":"关于我","content":"我是谁？我在哪儿？我要干什么？ 我，坐标 (ZJ,NB)\\texttt{(ZJ,NB)}(ZJ,NB)，现在是一名初二的学生。 曾经的博客在这里。 现在的博客在这里。 兴趣爱好广泛，是一个喜欢搞文化课和其他竞赛的 OIer\\texttt{OIer}OIer。 现在的水平大概是 TG\\texttt{TG}TG 组。 希望大家能多多指教~~ ","link":"https://20170952.github.io/Yxtbs.github.io/post/guan-yu-wo/"}]}