{"posts":[{"title":"Ynoi集合","content":"Ynoi集合 『在太阳西斜的这个世界里』—Broken Chronograph—\\color{#2CA9E1}\\texttt{『在太阳西斜的这个世界里』}\\\\\\scriptsize\\mathbf{—Broken\\ Chronograph—} 『在太阳西斜的这个世界里』—Broken Chronograph— 『置身天上之森』—Late Autumn Night′s Dream—\\color{#2CA9E1}\\texttt{『置身天上之森』}\\\\\\scriptsize\\mathbf{—Late\\ Autumn\\ Night&#x27;s\\ Dream—} 『置身天上之森』—Late Autumn Night′s Dream— 『等这场战争结束之后』—Starry Road To Tomorrow—\\color{#2CA9E1}\\texttt{『等这场战争结束之后』}\\\\\\scriptsize\\mathbf{—Starry\\ Road\\ To\\ Tomorrow—} 『等这场战争结束之后』—Starry Road To Tomorrow— 『不归之人与望眼欲穿的人们』—Dice In Pot—\\color{#2CA9E1}\\texttt{『不归之人与望眼欲穿的人们』}\\\\\\scriptsize\\mathbf{—Dice\\ In\\ Pot—} 『不归之人与望眼欲穿的人们』—Dice In Pot— 『人人本着正义之名』—From Down Till Dusk—\\color{#2CA9E1}\\texttt{『人人本着正义之名』}\\\\\\scriptsize\\mathbf{—From\\ Down\\ Till\\ Dusk—} 『人人本着正义之名』—From Down Till Dusk— 『长存不灭的过去，逐渐消逝的未来』—No News Was Good News—\\color{#2CA9E1}\\texttt{『长存不灭的过去，逐渐消逝的未来』}\\\\\\scriptsize\\mathbf{—No\\ News\\ Was\\ Good\\ News—} 『长存不灭的过去，逐渐消逝的未来』—No News Was Good News— 『我回来了』—Home , Sweet Home—\\color{Red}\\texttt{『我回来了』}\\\\\\scriptsize\\mathbf{—Home\\ ,\\ Sweet\\ Home—} 『我回来了』—Home , Sweet Home— 『纵使日薄西山』—Slight Light, Slight Hope—\\color{Red}\\texttt{『纵使日薄西山』}\\\\\\scriptsize\\mathbf{—Slight\\ Light,\\ Slight\\ Hope—} 『纵使日薄西山』—Slight Light, Slight Hope— 『即使看不到未来』—Moonlight Sorcery—\\color{Red}\\texttt{『即使看不到未来』}\\\\\\scriptsize\\mathbf{—Moonlight\\ Sorcery—} 『即使看不到未来』—Moonlight Sorcery— 『此时此刻的光辉』—My Happiness—\\color{Red}\\texttt{『此时此刻的光辉』}\\\\\\scriptsize\\mathbf{—My\\ Happiness—} 『此时此刻的光辉』—My Happiness— 『盼君勿忘』—Evidence of Existance—\\color{Red}\\texttt{『盼君勿忘』}\\\\\\scriptsize\\mathbf{—Evidence\\ of\\ Existance—} 『盼君勿忘』—Evidence of Existance— ————世上最幸福的女孩\\tag*{\\color{Magenta}\\texttt{————世上最幸福的女孩}} ————世上最幸福的女孩 \\color{white}\\texttt{} ","link":"https://20170952.github.io/Yxtbs.github.io/post/ynoi-ji-he/"},{"title":"CF1004C题解","content":"Codeforces Round #495 (Div. 2) C.Sonya and Robots Difficulty\\mathtt{Difficulty}Difficulty=1400\\mathtt{1400}1400 这道题目唯一的问题就是如何去重。 首先，对于数列中两个相同的数， 前面元素所成的数对， 后面元素一定都能造出。 那么我们就有了一个思路， 相同的数只需要算最后一个， 而前面的显然全部重复。 可以使用 set 维护， 然后代码就不难写出了。 #include&lt;bits/stdc++.h&gt; #define BetterIO ios::sync_with_stdio(false) using namespace std; #define int long long #define MAX 100001 int N,Ret,A[MAX],Cnt[MAX]; set&lt; int &gt;Set; signed main(void) { BetterIO; register int i;cin&gt;&gt;N; for(i=1;i&lt;=N;i++)cin&gt;&gt;A[i]; for(i=1;i&lt;=N;i++)Ret-=Cnt[A[i]],Ret+=(Cnt[A[i]]=Set.size()),Set.insert(A[i]); cout&lt;&lt;Ret&lt;&lt;endl; return 0; } ","link":"https://20170952.github.io/Yxtbs.github.io/post/cf1004c-ti-jie/"},{"title":"CF1304E题解","content":"Codeforces Round #620 (Div. 2) E.1-Trees and Queries Difficulty\\mathtt{Difficulty}Difficulty=2000\\mathtt{2000}2000 这道题目其实并没有 2000\\mathtt{2000}2000 的难度。 对于每一次询问，我们不妨进行分类讨论： 在原有的路径上走过去。 利用新增的边 (x,y)(x,y)(x,y) 走过去。 首先对于第一种情况， 我们显然是进行树上差分，即： Dist(X,Y)=Deep[X]+Deep[Y]-(Deep[GetLCA(X,Y)]&lt;&lt;1)。 而对于后一种情况， 我们不难想到是 Dist(A,X)+Dist(B,Y)+1， 或是 Dist(A,Y)+Dist(B,X)+1。 那么代码不难写出。 #include&lt;bits/stdc++.h&gt; #define BetterIO ios::sync_with_stdio(false) using namespace std; #define MAX 100001 struct Struct{int To,Next;}Edge[MAX&lt;&lt;1]; int N,Head[MAX],Deep[MAX],Jump[MAX][21],Count; inline void AddEdge(int U,int V){Edge[Count].To=V,Edge[Count].Next=Head[U],Head[U]=Count++;} inline void Dfs(int Now,int Father) { register int i; Deep[Now]=Deep[Father]+1,Jump[Now][0]=Father; for(i=1;(1&lt;&lt;i)&lt;=Deep[Now];i++)Jump[Now][i]=Jump[Jump[Now][i-1]][i-1]; for(i=Head[Now];~i;i=Edge[i].Next) { register int To(Edge[i].To); if(To!=Father)Dfs(To,Now); } } inline int GetLCA(int A,int B) { if(Deep[A]&gt;Deep[B])swap(A,B); register int i; for(i=20;i&gt;=0;i--)if(Deep[A]&lt;=Deep[B]-(1&lt;&lt;i))B=Jump[B][i]; if(A==B)return A; for(i=20;i&gt;=0;i--) { if(Jump[A][i]==Jump[B][i])continue; A=Jump[A][i],B=Jump[B][i]; } return Jump[A][0]; } inline int Dist(int X,int Y){return Deep[X]+Deep[Y]-2*Deep[GetLCA(X,Y)];} int main(void) { BetterIO; register int i;cin&gt;&gt;N; memset(Head,-1,sizeof(Head)); for(i=1;i&lt;N;i++) { register int U,V;cin&gt;&gt;U&gt;&gt;V; AddEdge(U,V); AddEdge(V,U); } Dfs(1,0); register int Q;cin&gt;&gt;Q;while(Q--) { register int X,Y,A,B,K;cin&gt;&gt;X&gt;&gt;Y&gt;&gt;A&gt;&gt;B&gt;&gt;K; register int D1(Dist(A,B)),D2(Dist(A,X)+Dist(B,Y)+1),D3(Dist(A,Y)+Dist(B,X)+1); if((K&gt;=D1&amp;&amp;!((K-D1)%2))||(K&gt;=D2&amp;&amp;!((K-D2)%2))||(K&gt;=D3&amp;&amp;!((K-D3)%2)))puts(&quot;YES&quot;); else puts(&quot;NO&quot;); } return 0; } ","link":"https://20170952.github.io/Yxtbs.github.io/post/cf1304e-ti-jie/"},{"title":"CF578B题解","content":"Codeforces Round #320 (Div. 1) [Bayan Thanks-Round] B.&quot;Or&quot; Game Difficulty\\mathtt{Difficulty}Difficulty=1700\\mathtt{1700}1700 不难发现，将 xkx^kxk 乘在同一个数上一定最优。 首先我们有 O(n2)\\mathcal{O(n^2)}O(n2) 的暴力算法。 于是我们考虑如何优化。 因为每次变化的只有一个数 aia_iai​， 所以我们不妨记录前缀或和后缀或， 然后枚举 iii 计算 ai×xka_i\\times x^kai​×xk 即可得到答案。 即：Ans=max(Ans,(A[i]*Ret)|Pre[i-1]|Nxt[i+1]) #include&lt;bits/stdc++.h&gt; using namespace std; #define int long long int N,K,X,A[200001],Pre[200001],Nxt[200001]; signed main(void) { register int i;cin&gt;&gt;N&gt;&gt;K&gt;&gt;X; for(i=1;i&lt;=N;i++)cin&gt;&gt;A[i]; register int Ret=1; while(K--)Ret*=X; for(i=1;i&lt;=N;i++)Pre[i]=Pre[i-1]|A[i]; for(i=N;i&gt;=1;i--)Nxt[i]=Nxt[i+1]|A[i]; register int Ans=0; for(i=1;i&lt;=N;i++)Ans=max(Ans,(A[i]*Ret)|Pre[i-1]|Nxt[i+1]); cout&lt;&lt;Ans&lt;&lt;endl; return 0; } ","link":"https://20170952.github.io/Yxtbs.github.io/post/cf578b-ti-jie/"},{"title":"CF1055E题解","content":"Mail.Ru Cup 2018 Round 2 E.Segments on the Line Difficulty\\mathtt{Difficulty}Difficulty=2500\\mathtt{2500}2500 不难想到二分答案 xxx，验证是否有 kkk 个及以上个的值小于 xxx。 对于这个问题，我们考虑 dp\\texttt{dp}dp。 不妨设 dpi,jdp_{i,j}dpi,j​ 表示前 iii 个点已经选择了 jjj 条线段。 转移考虑要么直接与上一个段重叠，要么不重叠（忽略包含的情况，因为这只意味着可以选择少于 mmm 段）。 重叠的情况下，选择上一个段显然是最优的。 不重叠的情况下，直接找包含这个点的左端点最左显然是最优的。 #include&lt;bits/stdc++.h&gt; #define BetterIO ios::sync_with_stdio(false) using namespace std; int N,M,S,K,A[10001],L[10001],R[10001],Dp[5001][5001]; inline bool Check(int X) { register int i,j;memset(Dp,0,sizeof(Dp)); for(i=1;i&lt;=N;i++) { register int Last(i+1),Sum(0); for(j=1;j&lt;=M;j++)if(L[j]&lt;=i&amp;&amp;R[j]&gt;=i)Last=min(Last,L[j]); for(j=Last;j&lt;=i;j++)Sum+=(A[j]&lt;=X); for(j=1;j&lt;=S;j++)Dp[i][j]=max(Dp[i-1][j],Dp[Last-1][j-1]+Sum); } return Dp[N][S]&gt;=K; } int main(void) { BetterIO; register int i;cin&gt;&gt;N&gt;&gt;M&gt;&gt;S&gt;&gt;K; for(i=1;i&lt;=N;i++)cin&gt;&gt;A[i]; for(i=1;i&lt;=M;i++)cin&gt;&gt;L[i]&gt;&gt;R[i]; register int Left(1),Right(1000000000),Ans=-1; while(Left&lt;=Right) { register int Middle=Left+Right&gt;&gt;1; if(Check(Middle))Ans=Middle,Right=Middle-1; else Left=Middle+1; } cout&lt;&lt;Ans&lt;&lt;endl; return 0; } ","link":"https://20170952.github.io/Yxtbs.github.io/post/cf1055e-ti-jie/"},{"title":"CF574B题解","content":"Codeforces Round #318 [RussianCodeCup Thanks-Round] (Div. 2) B.Bear and Three Musketeers Difficulty\\mathtt{Difficulty}Difficulty=1500\\mathtt{1500}1500 使用暴力可以通过本题。 我们考虑暴力枚举 333 个点， 条件为两两之间都有连边， 然后取这 333 个点的度数之和的最小值。 因为不包括这 333 个点本身， 所以最终答案还要 −6-6−6。 但是， 这样写会得到 TLE\\texttt{TLE}TLE， 不难想到一个基础的剪枝， 就是如果选的 222 个点已经没有连边， 就直接 break 掉。 代码就不难写出了。 #include&lt;bits/stdc++.h&gt; #define BetterIO ios::sync_with_stdio(false) using namespace std; int N,M,Deg[4001]; bool Map[4001][4001]; int main(void) { BetterIO; register int i,j,k;cin&gt;&gt;N&gt;&gt;M; for(i=1;i&lt;=M;i++) { register int U,V;cin&gt;&gt;U&gt;&gt;V; Map[U][V]=Map[V][U]=true,Deg[U]++,Deg[V]++; } register int Ret(INT_MAX); for(i=1;i&lt;=N;i++)for(j=i+1;j&lt;=N;j++)if(Map[i][j])for(k=j+1;k&lt;=N;k++)if(Map[i][j]&amp;&amp;Map[i][k]&amp;&amp;Map[j][k])Ret=min(Ret,Deg[i]+Deg[j]+Deg[k]); if(Ret==INT_MAX)Ret=5; cout&lt;&lt;Ret-6&lt;&lt;endl; return 0; } ","link":"https://20170952.github.io/Yxtbs.github.io/post/cf574b-ti-jie/"},{"title":"CF965D题解","content":"Codeforces Round #476 (Div. 2) [Thanks, Telegram!] D.Single-use Stones Difficulty\\mathtt{Difficulty}Difficulty=1900\\mathtt{1900}1900 先说结论： 最多通过的青蛙的数量就是每个长度为 lll 的区间中石头数量的最小值。 我们考虑一段长度为 lll 的区间， 因为青蛙最多跳 lll 的距离， 不难想到，每只青蛙都一定会在这个区间落下至少一次。 因为一定可以从另一个石子数大于等于 nnn 的区间跳过来， 所以这样取出的答案是可行的。 那么我们就得到了结论： 最多通过的青蛙的数量就是每个长度为 lll 的区间中石头数量的最小值。 代码就不难写出了。 #include&lt;bits/stdc++.h&gt; #define BetterIO ios::sync_with_stdio(false) using namespace std; int W,L,A[100001],Prefix[100001]; int main(void) { BetterIO; register int i;cin&gt;&gt;W&gt;&gt;L; for(i=1;i&lt;W;i++)cin&gt;&gt;A[i]; for(i=1;i&lt;W;i++)Prefix[i]=Prefix[i-1]+A[i]; register int Ret(INT_MAX); for(i=0;i+L&lt;W;i++)Ret=min(Ret,Prefix[i+L]-Prefix[i]); cout&lt;&lt;Ret&lt;&lt;endl; return 0; } ","link":"https://20170952.github.io/Yxtbs.github.io/post/cf965d-ti-jie/"},{"title":"CF1147C题解","content":"Forethought Future Cup - Final Round (Onsite Finalists Only) C.Thanos Nim Difficulty\\mathtt{Difficulty}Difficulty=2000\\mathtt{2000}2000 先说结论： 如果石子最小堆数量不超过 n2\\frac{n}{2}2n​ 时，先手必胜，反之后手必胜 如果石子最小堆数量超过了 n2\\frac{n}{2}2n​， 那么先手无论怎么选， 一定会选到一些最小堆， 这就会使得最小堆的数量减少 然后后手不妨将其余的非最小堆的一部分变成最小堆， 但是当最小堆数量变为 000 ， 而剩余堆超过 n2\\frac{n}{2}2n​ 时， 再操作一次即可获胜， 经过观察可知最后胜利者一定是后手 那么我们就得到了结论： 如果石子最小堆数量不超过 n2\\frac{n}{2}2n​ 时，先手必胜，反之后手必胜 代码就不难写出了 #include&lt;bits/stdc++.h&gt; #define BetterIO ios::sync_with_stdio(false) using namespace std; int N,A[1001]; int main(void) { BetterIO; #ifndef ONLINE_JUDGE freopen(&quot;IN.in&quot;,&quot;r&quot;,stdin); #endif register int i;cin&gt;&gt;N; for(i=1;i&lt;=N;i++)cin&gt;&gt;A[i]; sort(A+1,A+N+1); if(A[1]!=A[N/2+1])puts(&quot;Alice&quot;); else puts(&quot;Bob&quot;); return 0; } ","link":"https://20170952.github.io/Yxtbs.github.io/post/cf1147c-ti-jie/"},{"title":"P2893题解","content":"Luogu P2893 P2893.[USACO08FEB]Making the Grade G 这道题目我们可以考虑直接上 STL 我们一个数一个数地放进一个大根堆(优先队列) 其实就是算到当前数时 取前面最大的数出来 假如现在这个数比前面最大数大或相等就没事 反之我们则需要考虑如何改为不降 我们肯定是将大的往小移，将小的往大移 那么花费一定是 ∣a−b∣|a-b|∣a−b∣ 为了不影响先前的答案 当然都是移到同一基准 即是先前的最大数 代码不难写出 #include&lt;bits/stdc++.h&gt; #define BetterIO ios::sync_with_stdio(false) using namespace std; long long Total; priority_queue&lt; long long &gt;Queue; int main(void) { BetterIO; register long long i;cin&gt;&gt;Total; register long long Ans(0); for(i=1;i&lt;=Total;i++) { register long long Now;cin&gt;&gt;Now; Queue.push(Now); if(Queue.top()&gt;Now) { Ans+=Queue.top()-Now; Queue.pop(); Queue.push(Now); } } cout&lt;&lt;Ans&lt;&lt;endl; return 0; } ","link":"https://20170952.github.io/Yxtbs.github.io/post/p2893-ti-jie/"},{"title":"P4597题解","content":"Luogu P4597 P4597.序列sequence 这道题目我们可以考虑直接上 STL 我们一个数一个数地放进一个大根堆(优先队列) 其实就是算到当前数时 取前面最大的数出来 假如现在这个数比前面最大数大或相等就没事 反之我们则需要考虑如何改为不降 我们肯定是将大的往小移，将小的往大移 那么花费一定是 ∣a−b∣|a-b|∣a−b∣ 为了不影响先前的答案 当然都是移到同一基准 即是先前的最大数 代码不难写出 #include&lt;bits/stdc++.h&gt; #define BetterIO ios::sync_with_stdio(false) using namespace std; long long Total; priority_queue&lt; long long &gt;Queue; int main(void) { BetterIO; register long long i;cin&gt;&gt;Total; register long long Ans(0); for(i=1;i&lt;=Total;i++) { register long long Now;cin&gt;&gt;Now; Queue.push(Now); if(Queue.top()&gt;Now) { Ans+=Queue.top()-Now; Queue.pop(); Queue.push(Now); } } cout&lt;&lt;Ans&lt;&lt;endl; return 0; } ","link":"https://20170952.github.io/Yxtbs.github.io/post/p4597-ti-jie/"},{"title":"CF713C题解","content":"Codeforces Round #371 (Div. 1) C.Sonya and Problem Wihtout a Legend Difficulty\\mathtt{Difficulty}Difficulty=2300\\mathtt{2300}2300 这道题目我们可以考虑直接上 STL 我们一个数一个数地放进一个大根堆(优先队列) 其实就是算到当前数时 取前面最大的数出来 假如现在这个数比前面最大数大或相等就没事 反之我们则需要考虑如何改为不降 我们肯定是将大的往小移，将小的往大移 那么花费一定是 ∣a−b∣|a-b|∣a−b∣ 为了不影响先前的答案 当然都是移到同一基准 即是先前的最大数 代码不难写出 #include&lt;bits/stdc++.h&gt; #define BetterIO ios::sync_with_stdio(false) using namespace std; long long Total; priority_queue&lt; long long &gt;Queue; int main(void) { BetterIO; #ifndef ONLINE_JUDGE freopen(&quot;IN.in&quot;,&quot;r&quot;,stdin); #endif register long long i;cin&gt;&gt;Total; register long long Ans(0); for(i=1;i&lt;=Total;i++) { register long long Now;cin&gt;&gt;Now,Now-=i; Queue.push(Now); if(Queue.top()&gt;Now) { Ans+=Queue.top()-Now; Queue.pop(); Queue.push(Now); } } cout&lt;&lt;Ans&lt;&lt;endl; return 0; } ","link":"https://20170952.github.io/Yxtbs.github.io/post/cf713c-ti-jie/"},{"title":"CF13C题解","content":"Codeforces Beta Round #13 C.Sequence Difficulty\\mathtt{Difficulty}Difficulty=2200\\mathtt{2200}2200 这道题目我们可以考虑直接上 STL 我们一个数一个数地放进一个大根堆(优先队列) 其实就是算到当前数时 取前面最大的数出来 假如现在这个数比前面最大数大或相等就没事 反之我们则需要考虑如何改为不降 我们肯定是将大的往小移，将小的往大移 那么花费一定是 ∣a−b∣|a-b|∣a−b∣ 为了不影响先前的答案 当然都是移到同一基准 即是先前的最大数 代码不难写出 #include&lt;bits/stdc++.h&gt; #define BetterIO ios::sync_with_stdio(false) using namespace std; long long Total; priority_queue&lt; long long &gt;Queue; int main(void) { BetterIO; register long long i;cin&gt;&gt;Total; register long long Ans(0); for(i=1;i&lt;=Total;i++) { register long long Now;cin&gt;&gt;Now; Queue.push(Now); if(Queue.top()&gt;Now) { Ans+=Queue.top()-Now; Queue.pop(); Queue.push(Now); } } cout&lt;&lt;Ans&lt;&lt;endl; return 0; } ","link":"https://20170952.github.io/Yxtbs.github.io/post/cf13c-ti-jie/"},{"title":"CF594A题解","content":"Codeforces Round #330 (Div. 1) A.Warrior and Archer Difficulty\\mathtt{Difficulty}Difficulty=2300\\mathtt{2300}2300 这道题目其实算是一道结论题 我们首先将序列排个序 因为 A 要使两点距离尽可能近 然而 B 要使两点距离尽可能远 我们首先想到： A 肯定从两边开始取 B 肯定从中间开始取 这样破坏道只剩 222 个点的时候 因为一共少了 n−2n-2n−2 个点 所以每人取了 n2−1\\frac{n}{2}-12n​−1 个点 然后我们就得到了这道题的核心结论,即： 枚举距离为 n2\\frac{n}{2}2n​ 的点，再取最小值即可 代码不难写出 #include&lt;bits/stdc++.h&gt; #define BetterIO ios::sync_with_stdio(false) using namespace std; int N,A[200001]; int main(void) { BetterIO; #ifndef ONLINE_JUDGE freopen(&quot;IN.in&quot;,&quot;r&quot;,stdin); #endif register int i,j;cin&gt;&gt;N; for(i=1;i&lt;=N;i++)cin&gt;&gt;A[i]; sort(A+1,A+N+1); register int Ans(INT_MAX); for(i=1;(j=i+N/2)&lt;=N;i++)Ans=min(Ans,A[j]-A[i]); cout&lt;&lt;Ans&lt;&lt;endl; return 0; } ","link":"https://20170952.github.io/Yxtbs.github.io/post/cf594a-ti-jie/"},{"title":"CF1188B题解","content":"Codeforces Round #572 (Div. 1) B.Count Pairs Difficulty\\mathtt{Difficulty}Difficulty=2300\\mathtt{2300}2300 二话不说，先推一波式子 (ai+aj)(ai2+aj2)≡k(modp)(a_i+a_j)(a_i^2+a_j^2)\\equiv k\\pmod{p}(ai​+aj​)(ai2​+aj2​)≡k(modp) ⇒(ai+aj)(ai−aj)(ai2+aj2)≡k(ai−aj)(modp)\\Rightarrow (a_i+a_j)(a_i-a_j)(a_i^2+a_j^2)\\equiv k(a_i-a_j)\\pmod{p}⇒(ai​+aj​)(ai​−aj​)(ai2​+aj2​)≡k(ai​−aj​)(modp) ⇒ai4−aj4≡k(ai−aj)(modp)\\Rightarrow a_i^4-a_j^4\\equiv k(a_i-a_j)\\pmod{p}⇒ai4​−aj4​≡k(ai​−aj​)(modp) ⇒ai4−kai≡aj4−kaj(modp)\\Rightarrow a_i^4-ka_i\\equiv a_j^4-ka_j\\pmod{p}⇒ai4​−kai​≡aj4​−kaj​(modp) 推到这里就够了 我们发觉可以直接用 map 记录第 iii 个元素的 ai4−kaia_i^4-ka_iai4​−kai​ 对 ppp 取模的值 然后直接算答案即可 代码不难写出 #include&lt;bits/stdc++.h&gt; #define BetterIO ios::sync_with_stdio(false) using namespace std; #define int long long int N,K,MOD,A[300001]; map&lt; int,int &gt;Map; signed main(void) { BetterIO; register int i,Ans=0;cin&gt;&gt;N&gt;&gt;MOD&gt;&gt;K; for(i=1;i&lt;=N;i++) { register int Remainder;cin&gt;&gt;A[i],A[i]%=MOD; Remainder=A[i]*A[i]%MOD*A[i]%MOD*A[i]%MOD-K*A[i]%MOD+MOD; Ans+=Map[Remainder%MOD]; Map[Remainder%MOD]++; } cout&lt;&lt;Ans&lt;&lt;endl; return 0; } ","link":"https://20170952.github.io/Yxtbs.github.io/post/cf1188b-ti-jie/"},{"title":"模板集合","content":"My templates of C++ Decrease Const\\Large\\texttt{Decrease\\ Const}Decrease Const Pragma\\texttt{Pragma}Pragma Read\\texttt{Read}Read Write\\texttt{Write}Write IO\\texttt{IO}IO Decimal\\texttt{Decimal}Decimal Code\\texttt{Code}Code Code\\texttt{Code}Code Code\\texttt{Code}Code Code\\texttt{Code}Code Code\\texttt{Code}Code String\\Large\\texttt{String}String KMP\\texttt{KMP}KMP Trie\\texttt{Trie}Trie AC Automaton\\texttt{AC\\ Automaton}AC Automaton Hash\\texttt{Hash}Hash Code\\texttt{Code}Code Code\\texttt{Code}Code Code\\texttt{Code}Code Code\\texttt{Code}Code Geometry\\Large\\texttt{Geometry}Geometry Dist\\texttt{Dist}Dist Scan Line\\texttt{Scan Line}Scan Line Code\\texttt{Code}Code Code\\texttt{Code}Code Maths\\Large\\texttt{Maths}Maths GCD\\texttt{GCD}GCD LCM\\texttt{LCM}LCM Power\\texttt{Power}Power Combination\\texttt{Combination}Combination Inverse\\texttt{Inverse}Inverse Screen Prime\\texttt{Screen\\ Prime}Screen Prime Matrix\\texttt{Matrix}Matrix CRT\\texttt{CRT}CRT Check Prime\\texttt{Check\\ Prime}Check Prime ExGCD\\texttt{ExGCD}ExGCD Lucas\\texttt{Lucas}Lucas Phi\\texttt{Phi}Phi Code\\texttt{Code}Code Code\\texttt{Code}Code Code\\texttt{Code}Code Code\\texttt{Code}Code Code\\texttt{Code}Code Code\\texttt{Code}Code Code\\texttt{Code}Code Code\\texttt{Code}Code Code\\texttt{Code}Code Code\\texttt{Code}Code Code\\texttt{Code}Code Code\\texttt{Code}Code Data Structure\\Large\\texttt{Data\\ Structure}Data Structure Treap\\texttt{Treap}Treap BIT\\texttt{BIT}BIT DSU\\texttt{DSU}DSU ST\\texttt{ST}ST Mo\\texttt{Mo}Mo Chairman Tree\\texttt{Chairman\\ Tree}Chairman Tree Block\\texttt{Block}Block Segment Tree\\texttt{Segment\\ Tree}Segment Tree Monotone Stack\\texttt{Monotone\\ Stack}Monotone Stack Code\\texttt{Code}Code Code\\texttt{Code}Code Code\\texttt{Code}Code Code\\texttt{Code}Code Code\\texttt{Code}Code Code\\texttt{Code}Code Code\\texttt{Code}Code Code\\texttt{Code}Code Code\\texttt{Code}Code Graph\\Large\\texttt{Graph}Graph Kruskal\\texttt{Kruskal}Kruskal Bipartite Graph\\texttt{Bipartite\\ Graph}Bipartite Graph SPFA\\texttt{SPFA}SPFA Dijkstra\\texttt{Dijkstra}Dijkstra Floyd\\texttt{Floyd}Floyd LCA\\texttt{LCA}LCA Dinic\\texttt{Dinic}Dinic Mcmf(Dinic)\\texttt{Mcmf(Dinic)}Mcmf(Dinic) Chain Subdivision\\texttt{Chain\\ Subdivision}Chain Subdivision Code\\texttt{Code}Code Code\\texttt{Code}Code Code\\texttt{Code}Code Code\\texttt{Code}Code Code\\texttt{Code}Code Code\\texttt{Code}Code Code\\texttt{Code}Code Code\\texttt{Code}Code Code\\texttt{Code}Code ","link":"https://20170952.github.io/Yxtbs.github.io/post/mo-ban-ji-he/"},{"title":"CF1557场题解","content":"Codeforces Round #737 (Div. 2) A.Ezzat and Two Subsequences Difficulty\\mathtt{Difficulty}Difficulty=800\\mathtt{800}800 看完题目后，我们并不知道最优解该如何构造 然后我们观察样例及解释： 第一组，最终是 {1,2}\\{1,2\\}{1,2} 和 {3}\\{3\\}{3} 第二组，最终是 {−6,−7}\\{-6,-7\\}{−6,−7} 和 {−6}\\{-6\\}{−6} 然后我们不难得到一个猜想： 将最大的数单独为一组，其余为一组 代码实现简单 至于证明，我有一个很妙的解法，但是这里太小了，写不下😆 #include&lt;bits/stdc++.h&gt; #define BetterIO ios::sync_with_stdio(false) using namespace std; int N,A[100001]; #define int long long main(void) { BetterIO; register int Case;cin&gt;&gt;Case;while(Case--) { register int i;cin&gt;&gt;N; for(i=1;i&lt;=N;i++)cin&gt;&gt;A[i]; sort(A+1,A+N+1); register int Sum=0; for(i=1;i&lt;N;i++)Sum+=A[i]; printf(&quot;%.9lf\\n&quot;,1.0*Sum/(N-1)+1.0*A[N]); } return 0; } B.Moamen and k-subarrays Difficulty\\mathtt{Difficulty}Difficulty=1100\\mathtt{1100}1100 看完题目后，我们得到一个猜想： 只要将原串分成递增的小段即可 但是我们轻而易举地 hackhackhack 掉了 比如说前面有一个 {3,6}\\{3,6\\}{3,6} 后面有一个 {4}\\{4\\}{4} 就炸掉了 于是我们稍加改进，不难得到： 只要将原串分成递增的小段且是排完序紧挨的即可 然后可以用 pair 来优化写法，于是代码不难写出 #include&lt;bits/stdc++.h&gt; #define BetterIO ios::sync_with_stdio(false) using namespace std; int N,K,A[100001]; pair&lt; int,int &gt;B[100001]; int main(void) { BetterIO; register int Case;cin&gt;&gt;Case;while(Case--) { register int i;cin&gt;&gt;N&gt;&gt;K; for(i=1;i&lt;=N;i++)cin&gt;&gt;A[i]; for(i=1;i&lt;=N;i++)B[i].first=A[i],B[i].second=i; sort(B+1,B+N+1); register int Ans=0; for(i=2;i&lt;=N;i++)if(B[i].second!=B[i-1].second+1)Ans++; if(Ans&lt;K)puts(&quot;YES&quot;); else puts(&quot;NO&quot;); } return 0; } ","link":"https://20170952.github.io/Yxtbs.github.io/post/cf1557-chang-ti-jie/"},{"title":"CF1555场题解","content":"Educational Codeforces Round 112 (Rated for Div. 2) A.PizzaForces Difficulty\\mathtt{Difficulty}Difficulty=900\\mathtt{900}900 首先我们来枚举一下，得知：666 及以上的偶数都会刚好分完 而且每个披萨的性价比是一样的 那么，我们可以这样考虑： 如果人数不多于 666 人，那么也要 151515 分钟 如果人数多于 666 人且为偶数，那么肯定可以刚好吃完，没有多余 如果人数多于 666 人且为奇数，那么一定会剩下一个人的量 然后就不难写出代码了 #include&lt;bits/stdc++.h&gt; using namespace std; #define int long long signed main(void) { register int Case;cin&gt;&gt;Case;while(Case--) { register int N;cin&gt;&gt;N; if(N&lt;=6)cout&lt;&lt;15&lt;&lt;endl; else if(N&amp;1)cout&lt;&lt;(N+1)/2*5&lt;&lt;endl; else cout&lt;&lt;N/2*5&lt;&lt;endl; } return 0; } B.Two Tables Difficulty\\mathtt{Difficulty}Difficulty=1300\\mathtt{1300}1300 肯定是横着平移或者竖着平移才有可能作为最短距离 不难发现，我们一定只能把它移到边界上 那么我们不妨枚举 444 条边，然后依次判是否可行 最后再取一下答案即可 然后就不难写出代码了 #include&lt;bits/stdc++.h&gt; using namespace std; int N,M,A,B,C,D,E,F,P,Q; signed main(void) { register int Case;cin&gt;&gt;Case;while(Case--) { cin&gt;&gt;N&gt;&gt;M&gt;&gt;A&gt;&gt;B&gt;&gt;C&gt;&gt;D&gt;&gt;E&gt;&gt;F; register int Ans=1000000000; P=abs(A-C),Q=abs(B-D); if(P+E&lt;=N)Ans=min(Ans,min(max(0,E-N+max(A,C)),max(0,E-min(A,C)))); if(Q+F&lt;=M)Ans=min(Ans,min(max(0,F-M+max(B,D)),max(0,F-min(B,D)))); if(Ans&gt;=99999999)cout&lt;&lt;-1&lt;&lt;endl; else cout&lt;&lt;Ans&lt;&lt;&quot;.000000&quot;&lt;&lt;endl; } return 0; } C.Coin Rows Difficulty\\mathtt{Difficulty}Difficulty=1300\\mathtt{1300}1300 看懂题目之后，我们来观察样例 我们提出一个猜想：Bob 只能先一直往右，再一直往下或是先一直往下，再一直往右 然后我们考虑分别用前缀和维护一下，不然会 TLE\\texttt{TLE}TLE 维护完之后，暴力枚举 Alice 的路线即可 然后就不难写出代码了 #include&lt;bits/stdc++.h&gt; using namespace std; #define int long long int N; int Dp1[100001],Dp2[100001]; signed main(void) { register int Case;cin&gt;&gt;Case;while(Case--) { register int i;cin&gt;&gt;N; for(i=1;i&lt;=N;i++)Dp1[i]=Dp2[i]=0; for(i=1;i&lt;=N;i++){register int X;cin&gt;&gt;X;Dp1[i]=Dp1[i-1]+X;} for(i=1;i&lt;=N;i++){register int X;cin&gt;&gt;X;Dp2[i]=Dp2[i-1]+X;} register int Ans; Ans=min(Dp1[N]-Dp1[1],Dp2[N-1]); for(i=2;i&lt;N;i++)Ans=min(Ans,max(Dp1[N]-Dp1[i],Dp2[i-1])); if(N==1)Ans=0; cout&lt;&lt;Ans&lt;&lt;endl; } return 0; } D.Say No to Palindromes Difficulty\\mathtt{Difficulty}Difficulty=1600\\mathtt{1600}1600 这道题放在第四道，差评！ 实际上，看懂题目之后，我们不难想到一个结论： 该字符串一定是 a,b,ca,b,ca,b,c 的一个排列不断重复 然后我们干脆暴力枚举 666 种情况，但是我们会发现自己 TLE\\texttt{TLE}TLE 了 于是我们考虑加上一个前缀和维护，然后差分一把答案即可 然后就不难写出代码了 #include&lt;bits/stdc++.h&gt; using namespace std; int N,M; string S,S0[7]={&quot;&quot;,&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;}; int Prefix[7][200011]; int main(void) { register int i,j;cin&gt;&gt;N&gt;&gt;M;cin&gt;&gt;S;S=&quot;@&quot;+S; for(i=1;i&lt;=6;i++) { for(j=1;j&lt;=N;j++)if(S0[i][(j-1)%3]!=S[j])Prefix[i][j]=Prefix[i][j-1]+1; else Prefix[i][j]=Prefix[i][j-1]; } while(M--) { register int Left,Right;cin&gt;&gt;Left&gt;&gt;Right; register int Ans=Right-Left+1; for(i=1;i&lt;=6;i++)Ans=min(Ans,Prefix[i][Right]-Prefix[i][Left-1]); cout&lt;&lt;Ans&lt;&lt;endl; } return 0; } E.Boring Segments Difficulty\\mathtt{Difficulty}Difficulty=2100\\mathtt{2100}2100 题意是最小化最大值和最小值的差，不难想到 two-pointer\\texttt{two-pointer}two-pointer 枚举左端点，然后把上次的右端点继续向右移动即可 我们不妨使用线段树来维护这个区间 插入、删除就是在线段树 [l,r−1][l,r-1][l,r−1] 上加减，维护区间 时间复杂度 O(nlog⁡m)\\mathcal{O(n\\log m)}O(nlogm)，想必是正解吧 #include&lt;bits/stdc++.h&gt; using namespace std; struct Struct { int Left,Right,Value; inline bool operator &lt;(const Struct &amp;Compare)const { return Value&lt;Compare.Value; } }; struct Node { int Tmp,Tag; }; int N,M; Struct S[1000010]; Node C[4000040]; inline void Pd(int Rt) { if(C[Rt].Tag) { C[Rt*2].Tag+=C[Rt].Tag; C[Rt*2+1].Tag+=C[Rt].Tag; C[Rt*2].Tmp+=C[Rt].Tag; C[Rt*2+1].Tmp+=C[Rt].Tag; } C[Rt].Tag=0; } inline void Pu(int Rt) { C[Rt].Tmp=min(C[Rt*2].Tmp,C[Rt*2+1].Tmp); } inline void Add(int Rt,int L,int R,int LL,int RR,int VV) { if(L&gt;=LL&amp;&amp;R&lt;=RR){C[Rt].Tag+=VV,C[Rt].Tmp+=VV;return;} Pd(Rt); if((L+R&gt;&gt;1)&gt;=LL)Add(Rt*2,L,(L+R&gt;&gt;1),LL,RR,VV); if((L+R&gt;&gt;1)&lt;RR)Add(Rt*2+1,(L+R&gt;&gt;1)+1,R,LL,RR,VV); Pu(Rt); } int main(void) { register int i,Cnt=0,Ans=INT_MAX,T=0; cin&gt;&gt;N&gt;&gt;M,M--; for(i=1;i&lt;=N;i++)cin&gt;&gt;S[i].Left&gt;&gt;S[i].Right&gt;&gt;S[i].Value,S[i].Right--; sort(S+1,S+N+1); while(!C[1].Tmp)Cnt++,Add(1,1,M,S[Cnt].Left,S[Cnt].Right,1); Add(1,1,M,S[Cnt].Left,S[Cnt].Right,-1); for(i=Cnt;i&lt;=N;i++) { Add(1,1,M,S[i].Left,S[i].Right,1); while(C[1].Tmp)T++,Add(1,1,M,S[T].Left,S[T].Right,-1); Add(1,1,M,S[T].Left,S[T].Right,1); Ans=min(Ans,S[i].Value-S[T].Value),T--; } cout&lt;&lt;Ans&lt;&lt;endl; return 0; } ","link":"https://20170952.github.io/Yxtbs.github.io/post/cf1555-chang-ti-jie/"},{"title":"初等数论整理","content":"Some arrangement of division and congruence theory in elementary number theory. 整除理论 记号 Z={0,±1,±2,⋯ }\\mathbb{Z}=\\{0,\\pm 1,\\pm 2,\\cdots\\}Z={0,±1,±2,⋯} Q={ab∣a,b∈Z\\mathbb{Q}=\\{\\frac{a}{b}|a,b\\in \\mathbb{Z}Q={ba​∣a,b∈Z 且 b≠0}b\\ne 0\\}b​=0} R={\\mathbb{R}=\\{R={全体实数}\\}} C={\\mathbb{C}=\\{C={全体复数}\\}} 基础 设 a,b∈Za,b\\in \\mathbb{Z}a,b∈Z,则 a&lt;b,a&gt;ba&lt;b,a&gt;ba&lt;b,a&gt;b 或 a=ba=ba=b 若 a&lt;ba&lt;ba&lt;b,则 a≤b−1a\\le b-1a≤b−1 若 a&gt;ba&gt;ba&gt;b,则 a≥b+1a\\ge b+1a≥b+1 引题 观察:1,4,9,16,25,36,49⋯1,4,9,16,25,36,49\\cdots1,4,9,16,25,36,49⋯ 求方程 x2+y2=z2x^2+y^2=z^2x2+y2=z2 的所有正整数解 (x,y,z)(x,y,z)(x,y,z) ∑i=1ni=n(n+1)2=(n+12)\\sum\\limits_{i=1}^{n} i=\\frac{n(n+1)}{2}=\\dbinom{n+1}{2}i=1∑n​i=2n(n+1)​=(2n+1​),是否存在无穷多正整数 nnn 使得 n(n+1)2\\frac{n(n+1)}{2}2n(n+1)​ 为完全平方数？请求出是哪些 nnn? 证明: 令原式为 y2y^2y2,则 n(n+1)=2y2n(n+1)=2y^2n(n+1)=2y2,因此 4n(n+1)=8y24n(n+1)=8y^24n(n+1)=8y2 从而 (2n+1)2−8y2=1(2n+1)^2-8y^2=1(2n+1)2−8y2=1 即证:x2−8y2=1x^2-8y^2=1x2−8y2=1 有无穷个正整数解 (x,y)(x,y)(x,y) 理由: 32−8∗12=13^2-8*1^2=132−8∗12=1,即 (x,y)=(3,1)(x,y)=(3,1)(x,y)=(3,1) 是一组正整数解 如果 (x0,y0)(x_0,y_0)(x0​,y0​) 是原方程的一组正整数解,那么 {x02−8y02=132−8∗12=1\\begin{cases}x_0^2-8y_0^2=1\\\\3^2-8*1^2=1\\end{cases}{x02​−8y02​=132−8∗12=1​,因此 (x02−8y02)(32−8∗12)=1(x_0^2-8y_0^2)(3^2-8*1^2)=1(x02​−8y02​)(32−8∗12)=1 从而 (3x0+8y0+8x0+38y0)(3x0+8y0−8x0−38y0)=1(3x_0+8y_0+\\sqrt{8}x_0+3\\sqrt{8}y_0)(3x_0+8y_0-\\sqrt{8}x_0-3\\sqrt{8}y_0)=1(3x0​+8y0​+8​x0​+38​y0​)(3x0​+8y0​−8​x0​−38​y0​)=1 即有 (3x0+8y0)2−8(x0+3y0)2=1(3x_0+8y_0)^2-8(x_0+3y_0)^2=1(3x0​+8y0​)2−8(x0​+3y0​)2=1 令 {x1=3x0+8y0y1=x0+3y0\\begin{cases}x_1=3x_0+8y_0\\\\y_1=x_0+3y_0\\end{cases}{x1​=3x0​+8y0​y1​=x0​+3y0​​,则 x12−8y12=1x_1^2-8y_1^2=1x12​−8y12​=1,且 x1&gt;x0,y1&gt;y0x_1&gt;x_0,y_1&gt;y_0x1​&gt;x0​,y1​&gt;y0​ 即得结论成立 注记: 将符合条件的正整数 nnn 按照从小到大的顺序排列,分别记为 a1,a2,⋯a_1,a_2,\\cdotsa1​,a2​,⋯,求数列 {ak}k=1+∞\\{a_k\\}_{k=1}^{+\\infty}{ak​}k=1+∞​ 整除的定义 设 a,b∈Za,b\\in \\mathbb{Z}a,b∈Z,如果存在q∈Zq\\in \\mathbb{Z}q∈Z,使得 a=bqa=bqa=bq,那么称 bbb 整除 aaa,记为 b∣ab\\mid ab∣a 否则,qqq 不存在,那么称 bbb 不整除 aaa,记为 b∤ab\\nmid ab∤a 注记: 若 b∣ab\\mid ab∣a,则称 aaa 为 bbb 的倍数,bbb 为 aaa 的约数或因子 若 b∣ab\\mid ab∣a,则 ±b∣±a\\pm b\\mid \\pm a±b∣±a 若 b∣ab\\mid ab∣a 且 a=0a=0a=0,则 bbb 为任意的整数,因此 000 的因子为全体实数 用 τ(a)\\tau (a)τ(a) 表示 aaa 所有的不同的正因子的个数 整除的基本性质 若 a∣ba\\mid ba∣b,b∣cb\\mid cb∣c,则 a∣ca\\mid ca∣c 若 a∣ba\\mid ba∣b,a∣ca\\mid ca∣c,则 a∣bx+cya\\mid bx+cya∣bx+cy 带余除法定理 设 a,b∈Za,b\\in \\mathbb{Z}a,b∈Z 且 b&gt;0b&gt;0b&gt;0,那么存在唯一的 q,r∈Zq,r\\in \\mathbb{Z}q,r∈Z 使得: a=bq+ra=bq+r a=bq+r 其中 0≤r&lt;b0\\le r&lt;b0≤r&lt;b 注记: ab=q+rb,0≤rb&lt;1\\frac{a}{b}=q+\\frac{r}{b},0\\le \\frac{r}{b}&lt;1ba​=q+br​,0≤br​&lt;1,因此 q=⌊ab⌋q=\\left\\lfloor\\frac{a}{b}\\right\\rfloorq=⌊ba​⌋,熟知x−1&lt;⌊x⌋,∀x∈Rx-1&lt;\\left\\lfloor x\\right\\rfloor,\\forall x\\in \\mathbb{R}x−1&lt;⌊x⌋,∀x∈R,a−(b−1)b≤⌊ab⌋≤ab\\frac{a-(b-1)}{b}\\le \\left\\lfloor\\frac{a}{b}\\right\\rfloor\\le \\frac{a}{b}ba−(b−1)​≤⌊ba​⌋≤ba​ 设 n,bn,bn,b 均为正整数,问 1,2,⋯ ,n1,2,\\cdots,n1,2,⋯,n 中能被 bbb 整除的整数的个数为几个？ 解: 不妨设 n=bq+r,0≤r&lt;bn=bq+r,0\\le r&lt;bn=bq+r,0≤r&lt;b 个数即为 qqq 个,分别为r,2r,⋯ ,qrr,2r,\\cdots,qrr,2r,⋯,qr 设 {an}\\{a_n\\}{an​} 是给定的 nnn 个整数,证明:{an}\\{a_n\\}{an​}中一定存在部分数和为 nnn 的倍数。 证明: 考虑一下项的和:∑i=11ai\\sum\\limits_{i=1}^{1}a_ii=1∑1​ai​,∑i=12ai\\sum\\limits_{i=1}^{2}a_ii=1∑2​ai​,∑i=13ai\\sum\\limits_{i=1}^{3}a_ii=1∑3​ai​,⋯\\cdots⋯,∑i=1nai\\sum\\limits_{i=1}^{n}a_ii=1∑n​ai​ 分类讨论： 若上述 nnn 式中有一个值为 nnn 的倍数,那么结论显然成立 若上述 nnn 式中没有一个值为 nnn 的倍数,那么由抽屉原理,存在 1≤i&lt;j≤n1\\le i&lt;j\\le n1≤i&lt;j≤n 使得: ∑k=1iak\\sum\\limits_{k=1}^{i}a_kk=1∑i​ak​,∑k=1jak\\sum\\limits_{k=1}^{j}a_kk=1∑j​ak​ 除以 nnn 所得余数相同，因此有： n∣∑k=i+1jakn\\mid \\sum\\limits_{k=i+1}^{j}a_k n∣k=i+1∑j​ak​ 综上所述,结论成立 公因子和最大公因子的定义 设 a,b∈Za,b\\in \\mathbb{Z}a,b∈Z,不全为 000,如果 d∣ad\\mid ad∣a 且 d∣bd\\mid bd∣b,那么称 ddd 为 a,ba,ba,b 的一个公因子 设 a,b∈Za,b\\in \\mathbb{Z}a,b∈Z,不全为 000,如果 ddd 是 a,ba,ba,b 的一个公因子,且 ddd 是最大的,那么称 ddd 为 a,ba,ba,b 的最大公因子,记为: d=(a,b)d=(a,b) d=(a,b) 最大公因子的性质 (a,0)=∣a∣(a,0)=|a|(a,0)=∣a∣,(a,1)=1(a,1)=1(a,1)=1 (a,b)=(b,a)=(±a,±b)(a,b)=(b,a)=(\\pm a,\\pm b)(a,b)=(b,a)=(±a,±b) (a,b)=(a−b,b)(a,b)=(a-b,b)(a,b)=(a−b,b) 证明: 令 d=(a,b),d1=(a−b,b)d=(a,b),d_1=(a-b,b)d=(a,b),d1​=(a−b,b),即证:d=d1d=d_1d=d1​ 先证 d≤d1d\\le d_1d≤d1​:由于 d=(a,b)d=(a,b)d=(a,b),那么 d∣ad\\mid ad∣a 且 d∣bd\\mid bd∣b,因此 d∣a−bd\\mid a-bd∣a−b 且 d∣bd\\mid bd∣b,又 d1=(a−b,b)d_1=(a-b,b)d1​=(a−b,b),即得 d≤d1d\\le d_1d≤d1​ 再证 d≥d1d\\ge d_1d≥d1​:由于 d1=(a−b,b)d_1=(a-b,b)d1​=(a−b,b),那么 d1∣a−bd_1\\mid a-bd1​∣a−b 且 d1∣bd_1\\mid bd1​∣b,因此 d1∣(a−b)+b=ad_1\\mid (a-b)+b=ad1​∣(a−b)+b=a 且 d1∣bd_1\\mid bd1​∣b,又 d=(a,b)d=(a,b)d=(a,b),即得 d≥d1d\\ge d_1d≥d1​ 综上所述,结论成立 辗转相除法:(a,b)=(a−bq,b),∀q∈Z(a,b)=(a-bq,b),\\forall q\\in \\mathbb{Z}(a,b)=(a−bq,b),∀q∈Z 证明: 若 q≥1q\\ge 1q≥1,则(a,b)=(a−b,b)=⋯=(a−bq,b)(a,b)=(a-b,b)=\\cdots=(a-bq,b)(a,b)=(a−b,b)=⋯=(a−bq,b) 若 q=0q=0q=0,则(a,b)=(a−bq,b)(a,b)=(a-bq,b)(a,b)=(a−bq,b) 若 q≤−1q\\le -1q≤−1,则(a,b)=(a+b,b)=⋯=(a+b∣q∣,b)=(a−bq,b)(a,b)=(a+b,b)=\\cdots=(a+b|q|,b)=(a-bq,b)(a,b)=(a+b,b)=⋯=(a+b∣q∣,b)=(a−bq,b) Bezout 定理 设 a,b∈Za,b\\in \\mathbb{Z}a,b∈Z,不全为 000,那么存在 s,t∈Zs,t\\in \\mathbb{Z}s,t∈Z 使得: as+bt=(a,b)as+bt=(a,b) as+bt=(a,b) 证明: 先构造一个集合 S={ax+by∣x,y∈Z}S=\\{ax+by|x,y\\in \\mathbb{Z}\\}S={ax+by∣x,y∈Z} 显然,±a,±b∈S\\pm a,\\pm b \\in S±a,±b∈S,因此 SSS 中存在正整数 不妨设 SSS 中最小的正整数为 ddd,则 d∈Sd\\in Sd∈S,从而: d=ax0+by0d=ax_0+by_0 d=ax0​+by0​ d∣ad\\mid ad∣a 且 d∣bd\\mid bd∣b 对任意的 d1∈Zd_1\\in \\mathbb{Z}d1​∈Z,d1∣ad_1\\mid ad1​∣a 且 d1∣bd_1\\mid bd1​∣b,由于 d=ax0+by0d=ax_0+by_0d=ax0​+by0​,那么 d1∣dd_1\\mid dd1​∣d 综上所述,(a,b)=d=ax0+by0(a,b)=d=ax_0+by_0(a,b)=d=ax0​+by0​ 推论 设 a,b∈Za,b\\in \\mathbb{Z}a,b∈Z,不全为 000,如果 ddd 为 a,ba,ba,b 的一个公因子,则有: d∣(a,b)d\\mid (a,b) d∣(a,b) 证明: 由 Bezout 定理,有as+bt=(a,b)as+bt=(a,b)as+bt=(a,b),又 d∣ad\\mid ad∣a 且 d∣bd\\mid bd∣b,那么 d∣as+bt=(a,b)d\\mid as+bt=(a,b)d∣as+bt=(a,b) 设 a,b∈Za,b\\in \\mathbb{Z}a,b∈Z,不全为 000,那么存在 s,t∈Zs,t\\in \\mathbb{Z}s,t∈Z 使得: as+bt=(a,b)as+bt=(a,b) as+bt=(a,b) 因此,a(a,b)s+b(a,b)t=1\\frac{a}{(a,b)}s+\\frac{b}{(a,b)}t=1(a,b)a​s+(a,b)b​t=1,从而: (a(a,b),b(a,b))=1(\\frac{a}{(a,b)},\\frac{b}{(a,b)})=1 ((a,b)a​,(a,b)b​)=1 注记: 若 (a,b)=1(a,b)=1(a,b)=1,则称 a,ba,ba,b 是互质或互素的 (a,a+1)=1(a,a+1)=1(a,a+1)=1,(2k−1,2k+1)=1(2k-1,2k+1)=1(2k−1,2k+1)=1,(2a,2k+1)=1(2^a,2k+1)=1(2a,2k+1)=1 整除的高级性质 若 (a,b)=1(a,b)=1(a,b)=1,且 a∣bca\\mid bca∣bc,则有 a∣ca\\mid ca∣c 证明: 由于 (a,b)=1(a,b)=1(a,b)=1,由 Bezout 定理,有 as+bt=1as+bt=1as+bt=1 在上式的两边同时乘上 ccc,有 acs+bct=cacs+bct=cacs+bct=c 又 a∣bca\\mid bca∣bc,a∣aa\\mid aa∣a,那么 a∣acs+bcta\\mid acs+bcta∣acs+bct,从而 a∣ca\\mid ca∣c 如果 (a,b)=1(a,b)=1(a,b)=1,且 a∣ca\\mid ca∣c,b∣cb\\mid cb∣c,则ab∣cab\\mid cab∣c 证明: 由于 (a,b)=1(a,b)=1(a,b)=1,那么存在 s,t∈Zs,t\\in \\mathbb{Z}s,t∈Z 使得 as+bt=1as+bt=1as+bt=1 在上式的两边同时乘上 ccc,有 acs+bct=cacs+bct=cacs+bct=c 又 a∣ca\\mid ca∣c,则 ab∣bcab\\mid bcab∣bc,又 b∣cb\\mid cb∣c,则 ab∣acab\\mid acab∣ac,因此 ab∣abs+cbtab\\mid abs+cbtab∣abs+cbt,从而 ab∣cab\\mid cab∣c 最大公因子的高级性质 若 (a,b)=1(a,b)=1(a,b)=1,则 (a,bc)=(a,c)(a,bc)=(a,c)(a,bc)=(a,c) 证明: 令 d=(a,bc),d1=(a,c)d=(a,bc),d_1=(a,c)d=(a,bc),d1​=(a,c),即证 d=d1d=d_1d=d1​ 先证 d∣d1d\\mid d_1d∣d1​:由于 d1=(a,c)d_1=(a,c)d1​=(a,c),那么 d1∣ad_1\\mid ad1​∣a 且 d1∣cd_1\\mid cd1​∣c,又 c∣bcc\\mid bcc∣bc,那么 d1∣bcd_1\\mid bcd1​∣bc 且 d1∣ad_1\\mid ad1​∣a,又 d=(a,bc)d=(a,bc)d=(a,bc),即得 d1∣dd_1\\mid dd1​∣d 再证 d1∣dd_1\\mid dd1​∣d:由于 d=(a,bc)d=(a,bc)d=(a,bc),则 d∣ad\\mid ad∣a 且 d∣bcd\\mid bcd∣bc,又 (a,b)=1(a,b)=1(a,b)=1,由 Bezout 定理,有 as+bt=1as+bt=1as+bt=1,因此 acs+bct=cacs+bct=cacs+bct=c,从而 d∣cd\\mid cd∣c,又 d∣ad\\mid ad∣a 且 d1=(a,c)d_1=(a,c)d1​=(a,c),即得 d1∣dd_1\\mid dd1​∣d 综上所述,结论成立 令 d=(ab,c),d1=(a,c),d2=(b,c)d=(ab,c),d_1=(a,c),d_2=(b,c)d=(ab,c),d1​=(a,c),d2​=(b,c),则 d=d1d2d=d_1d_2d=d1​d2​ 证明: 先证:d∣d1d2d\\mid d_1d_2d∣d1​d2​:由 Bezout 定理,有 {as1+ct1=d1bs2+ct2=d2\\begin{cases}as_1+ct_1=d_1\\\\bs_2+ct_2=d_2\\end{cases}{as1​+ct1​=d1​bs2​+ct2​=d2​​ 因此 d1d2=(as1+ct1)(bs2+ct2)d_1d_2=(as_1+ct_1)(bs_2+ct_2)d1​d2​=(as1​+ct1​)(bs2​+ct2​),从而 abs1s2+c(as1t2+bs2t1+ct1t2)abs_1s_2+c(as_1t_2+bs_2t_1+ct_1t_2)abs1​s2​+c(as1​t2​+bs2​t1​+ct1​t2​) 又 d=(ab,c)d=(ab,c)d=(ab,c),则 d∣abd\\mid abd∣ab 且 d∣cd\\mid cd∣c,从而 d∣d1d2d\\mid d_1d_2d∣d1​d2​ 再证:d1d2∣dd_1d_2\\mid dd1​d2​∣d:由于 (a,b)=1(a,b)=1(a,b)=1,由 Bezout 定理,有 as+bt=1as+bt=1as+bt=1,从而 acs+cbt=cacs+cbt=cacs+cbt=c 由于 d1=(a,c)d_1=(a,c)d1​=(a,c),d2=(b,c)d_2=(b,c)d2​=(b,c),那么 d1∣ad_1\\mid ad1​∣a 且 d1∣cd_1\\mid cd1​∣c,d2∣bd_2\\mid bd2​∣b 且 d2∣cd_2\\mid cd2​∣c 因此 d1d2∣abd_1d_2\\mid abd1​d2​∣ab,d1d2∣acd_1d_2\\mid acd1​d2​∣ac,d1d2∣bcd_1d_2\\mid bcd1​d2​∣bc 又 d=(ab,c)d=(ab,c)d=(ab,c),即得 d1d2∣dd_1d_2\\mid dd1​d2​∣d 综上所述,结论成立 素数与合数 设正整数 n&gt;1n&gt;1n&gt;1,如果 nnn 的所有不同正因子恰好为 111 和它本身,那么称 nnn 为素数(Euclid 定理:素数有无穷多个) 设正整数 n&gt;1n&gt;1n&gt;1,如果 nnn 不是素数,那么称 nnn 为合数 任意正整数 nnn,存在连续的几个正整数均为合数 解: (n+1)!+2,(n+1)!+3,⋯ ,(n+1)!+(n+1)(n+1)!+2,(n+1)!+3,\\cdots,(n+1)!+(n+1)(n+1)!+2,(n+1)!+3,⋯,(n+1)!+(n+1) 任意正整数 nnn,存在连续的几个正整数均为合数,且每一个正整数均不能写成两个整数的平方和 猜想: 存在无穷个正整数 nnn,使得 n!+1n!+1n!+1 为素数 存在无穷个正整数 nnn,使得 n!+1n!+1n!+1 为合数 素数的性质 设 ppp 为素数,a∈Za\\in \\mathbb{Z}a∈Z,则 (a,p)=1(a,p)=1(a,p)=1 或 p∣ap\\mid ap∣a 证明: 令 d=(a,p)d=(a,p)d=(a,p),则 d∣ad\\mid ad∣a 且 d∣pd\\mid pd∣p,因此 d=1d=1d=1 或 ppp 若 d=1d=1d=1,那么 (a,p)=1(a,p)=1(a,p)=1,结论成立 若 d=pd=pd=p,那么 p∣ap\\mid ap∣a,结论成立 综上所述,结论成立 设 ppp 为素数且 p∣abp\\mid abp∣ab,a,b∈Za,b\\in \\mathbb{Z}a,b∈Z,则 p∣ap\\mid ap∣a 或 p∣bp\\mid bp∣b 证明: 分类讨论: 若 p∣ap\\mid ap∣a,则结论显然成立 若 p∤ap\\nmid ap∤a,那么 (a,p)=1(a,p)=1(a,p)=1,又 p∣abp\\mid abp∣ab,因此 p∣bp\\mid bp∣b,结论成立 综上所述,结论成立 算术基本定理 设正整数 n&gt;1n&gt;1n&gt;1,那么 nnn 可以写成有限个素数之积,如果不考虑乘积的顺序,则这种分解就是唯一的,即: n=p1α1p2α2p3α3⋯ptαtn=p_1^{\\alpha_1} p_2^{\\alpha_2} p_3^{\\alpha_3} \\cdots p_t^{\\alpha_t} n=p1α1​​p2α2​​p3α3​​⋯ptαt​​ 其中 p1&lt;p2&lt;p3&lt;⋯&lt;ptp_1&lt;p_2&lt;p_3&lt;\\cdots&lt;p_tp1​&lt;p2​&lt;p3​&lt;⋯&lt;pt​,αi≥1,i=1,2,⋯ ,t\\alpha_i\\ge 1,i=1,2,\\cdots,tαi​≥1,i=1,2,⋯,t 令 Sk(n)=∑i=1nikS_k(n)=\\sum\\limits_{i=1}^{n}i^kSk​(n)=i=1∑n​ik 显然{S1(n)=∑i=1ni=n(n+1)2S2(n)=∑i=1ni2=n(n+1)(2n+1)6S3(n)=∑i=1ni3=(n(n+1)2)2\\begin{cases}S_1(n)=\\sum\\limits_{i=1}^{n}i=\\frac{n(n+1)}{2}\\\\S_2(n)=\\sum\\limits_{i=1}^{n}i^2=\\frac{n(n+1)(2n+1)}{6}\\\\S_3(n)=\\sum\\limits_{i=1}^{n}i^3=(\\frac{n(n+1)}{2})^2\\end{cases}⎩⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎧​S1​(n)=i=1∑n​i=2n(n+1)​S2​(n)=i=1∑n​i2=6n(n+1)(2n+1)​S3​(n)=i=1∑n​i3=(2n(n+1)​)2​ 观察:Sk(1),Sk(2),⋯ ,Sk(n),⋯S_k(1),S_k(2),\\cdots,S_k(n),\\cdotsSk​(1),Sk​(2),⋯,Sk​(n),⋯ 一般情况,计算 Sk(n)S_k(n)Sk​(n) 的值 解: (x+1)k+1−xk+1=∑i=0kxi(k+1i)(x+1)^{k+1}-x^{k+1}=\\sum\\limits_{i=0}^{k}x^i\\dbinom{k+1}{i}(x+1)k+1−xk+1=i=0∑k​xi(ik+1​) 因此,(n+1)k+1−1=∑i=1kSi(n)(k+1i)+n(n+1)^{k+1}-1=\\sum\\limits_{i=1}^{k}S_i(n)\\dbinom{k+1}{i}+n(n+1)k+1−1=i=1∑k​Si​(n)(ik+1​)+n 证明641∣232+1641\\mid 2^{32}+1641∣232+1 证明: RHS=232+1=4294967297RHS=2^{32}+1=4294967297RHS=232+1=4294967297 因此,641∣232+1641\\mid 2^{32}+1641∣232+1 注记: 称该式为 nnn 的标准分解式 推论:设 nnn 为正整数,则有 n=2abn=2^abn=2ab,其中 2∤b2\\nmid b2∤b,a&gt;0a&gt;0a&gt;0 同余理论 同余的定义 设 mmm 为正整数,a,b∈Za,b\\in \\mathbb{Z}a,b∈Z,如果 m∣a−bm\\mid a-bm∣a−b,那么称 aaa 同余 bbb 模 mmm,记为 a≡b(modm)a\\equiv b\\pmod{m} a≡b(modm) 否则,若 m∤a−bm\\nmid a-bm∤a−b,那么称 aaa 不同余 bbb 模 mmm,记为 a≡b(modm)a\\not\\equiv b\\pmod{m} a​≡b(modm) 注记: a≡b(modm) ⟺ m∣a−b ⟺ a=b+mq,∃q∈Za\\equiv b\\pmod{m}\\iff m\\mid a-b\\iff a=b+mq,\\exists q\\in \\mathbb{Z}a≡b(modm)⟺m∣a−b⟺a=b+mq,∃q∈Z 设 a∈Za\\in \\mathbb{Z}a∈Z,则 a2≡0,1(mod4)a^2\\equiv 0,1\\pmod{4}a2≡0,1(mod4) 特别地,若 2∤a2\\nmid a2∤a,则 a2≡1(mod8)a^2\\equiv 1\\pmod{8}a2≡1(mod8) 证明: 若 a=2ka=2ka=2k,那么 a2=(2k)2=4k2≡0(mod4)a^2=(2k)^2=4k^2\\equiv 0\\pmod{4}a2=(2k)2=4k2≡0(mod4) 若 a=2k+1a=2k+1a=2k+1,那么 a2=(2k+1)2=4k2+4k+1=4k(k+1)+1≡1(mod8)a^2=(2k+1)^2=4k^2+4k+1=4k(k+1)+1\\equiv 1\\pmod{8}a2=(2k+1)2=4k2+4k+1=4k(k+1)+1≡1(mod8) 综上所述,结论成立 对每个正整数 nnn,均有 ⌊n+n+1⌋=⌊n+n+2⌋\\left\\lfloor\\sqrt{n}+\\sqrt{n+1}\\right\\rfloor=\\left\\lfloor\\sqrt{n}+\\sqrt{n+2}\\right\\rfloor⌊n​+n+1​⌋=⌊n​+n+2​⌋ 分析: ⌊x⌋\\left\\lfloor x\\right\\rfloor⌊x⌋的性质 x=⌊x⌋+{x}x=\\left\\lfloor x\\right\\rfloor+\\{x\\}x=⌊x⌋+{x},其中 ⌊x⌋∈Z\\left\\lfloor x\\right\\rfloor\\in \\mathbb{Z}⌊x⌋∈Z,0≤{x}&lt;10\\le\\{x\\}&lt;10≤{x}&lt;1 x−1&lt;⌊x⌋≤x&lt;⌊x⌋+1x-1&lt;\\left\\lfloor x\\right\\rfloor\\le x&lt;\\left\\lfloor x\\right\\rfloor+1x−1&lt;⌊x⌋≤x&lt;⌊x⌋+1 ⌊x+n⌋=⌊x⌋+n\\left\\lfloor x+n\\right\\rfloor=\\left\\lfloor x\\right\\rfloor +n⌊x+n⌋=⌊x⌋+n,x∈Rx\\in \\mathbb{R}x∈R,n∈Zn\\in \\mathbb{Z}n∈Z {x+n}={x}\\{x+n\\}=\\{x\\}{x+n}={x},∀n∈Z\\forall n\\in \\mathbb{Z}∀n∈Z ⌊x⌋+⌊y⌋≤⌊x+y⌋≤⌊x⌋+⌊y⌋+1\\left\\lfloor x\\right\\rfloor+\\left\\lfloor y\\right\\rfloor\\le \\left\\lfloor x+y\\right\\rfloor\\le \\left\\lfloor x\\right\\rfloor+\\left\\lfloor y\\right\\rfloor+1⌊x⌋+⌊y⌋≤⌊x+y⌋≤⌊x⌋+⌊y⌋+1 ⌊−x⌋={−⌊−x⌋,x∈Z⌊−x⌋+1,x∉Z\\left\\lfloor {-x}\\right\\rfloor=\\begin{cases}{-\\left\\lfloor -x\\right\\rfloor,x\\in \\mathbb{Z}}\\\\{\\left\\lfloor -x\\right\\rfloor+1,x\\notin \\mathbb{Z}}\\end{cases}⌊−x⌋={−⌊−x⌋,x∈Z⌊−x⌋+1,x∈/​Z​ 回到原题 反证法,如果结论不对,那么存在正整数 nnn,使得 ⌊n+n+1⌋≠⌊n+n+2⌋\\left\\lfloor\\sqrt{n}+\\sqrt{n+1}\\right\\rfloor\\ne\\left\\lfloor\\sqrt{n}+\\sqrt{n+2}\\right\\rfloor⌊n​+n+1​⌋​=⌊n​+n+2​⌋ 因此,⌊n+n+1⌋&lt;⌊n+n+2⌋\\left\\lfloor\\sqrt{n}+\\sqrt{n+1}\\right\\rfloor&lt;\\left\\lfloor\\sqrt{n}+\\sqrt{n+2}\\right\\rfloor⌊n​+n+1​⌋&lt;⌊n​+n+2​⌋ 令 k=⌊n+n+2⌋k=\\left\\lfloor\\sqrt{n}+\\sqrt{n+2}\\right\\rfloork=⌊n​+n+2​⌋,则 ⌊n+n+1⌋&lt;k≤⌊n+n+2⌋\\left\\lfloor\\sqrt{n}+\\sqrt{n+1}\\right\\rfloor&lt;k\\le\\left\\lfloor\\sqrt{n}+\\sqrt{n+2}\\right\\rfloor⌊n​+n+1​⌋&lt;k≤⌊n​+n+2​⌋ 因此,(⌊n+n+1⌋)2&lt;k2≤(⌊n+n+2⌋)2(\\left\\lfloor\\sqrt{n}+\\sqrt{n+1}\\right\\rfloor)^2&lt;k^2\\le(\\left\\lfloor\\sqrt{n}+\\sqrt{n+2}\\right\\rfloor)^2(⌊n​+n+1​⌋)2&lt;k2≤(⌊n​+n+2​⌋)2 从而,2n+1+2n2+n&lt;k2≤2n+2+2n2+2n2n+1+2\\sqrt{n^2+n}&lt;k^2\\le 2n+2+2\\sqrt{n^2+2n}2n+1+2n2+n​&lt;k2≤2n+2+2n2+2n​,2n+1+2n2&lt;k2≤2n+2+2n2+2n+12n+1+2\\sqrt{n^2}&lt;k^2\\le 2n+2+2\\sqrt{n^2+2n+1}2n+1+2n2​&lt;k2≤2n+2+2n2+2n+1​ 因此,4n+1&lt;k2&lt;4n+44n+1&lt;k^2&lt;4n+44n+1&lt;k2&lt;4n+4 从而,k2=4k+2k^2=4k+2k2=4k+2 或 4k+34k+34k+3,k2≡0k^2\\equiv 0k2≡0 或 1(mod4)1\\pmod{4}1(mod4),矛盾 综上所述,结论成立 同余的基本性质 a≡a(modm)a\\equiv a\\pmod{m}a≡a(modm),反身性 若 a≡b(modm)a\\equiv b\\pmod{m}a≡b(modm),则 b≡a(modm)b\\equiv a\\pmod{m}b≡a(modm),对称性 若 a≡b(modm)a\\equiv b\\pmod{m}a≡b(modm),b≡c(modm)b\\equiv c\\pmod{m}b≡c(modm),则 a≡c(modm)a\\equiv c\\pmod{m}a≡c(modm),传递性 注记: 若 a1≡a2(modm),a2≡a3(modm),⋯ ,at−1≡at(modm)a_1\\equiv a_2\\pmod{m},a_2\\equiv a_3\\pmod{m},\\cdots,a_{t-1}\\equiv a_t\\pmod{m}a1​≡a2​(modm),a2​≡a3​(modm),⋯,at−1​≡at​(modm),则:a1≡a2≡a3⋯≡at(modm)a_1\\equiv a_2\\equiv a_3\\cdots\\equiv a_t\\pmod{m}a1​≡a2​≡a3​⋯≡at​(modm) 同余的性质 若 a≡b(modm)a\\equiv b\\pmod{m}a≡b(modm),c≡d(modm)c\\equiv d\\pmod{m}c≡d(modm),那么: a+c≡b+d(modm)a+c\\equiv b+d\\pmod{m} a+c≡b+d(modm) a−c≡b−d(modm)a-c\\equiv b-d\\pmod{m} a−c≡b−d(modm) ac≡bd(modm)ac\\equiv bd\\pmod{m} ac≡bd(modm) 若 ab≡ac(modm)ab\\equiv ac\\pmod{m}ab≡ac(modm),则 b≡c(modm(a,m))b\\equiv c\\pmod{\\frac{m}{(a,m)}}b≡c(mod(a,m)m​) 同余的高级性质 若 a1≡b1(modm),a2≡b2(modm),⋯ ,at≡bt(modm),t≥2a_1\\equiv b_1\\pmod{m},a_2\\equiv b_2\\pmod{m},\\cdots,a_t\\equiv b_t\\pmod{m},t\\ge 2a1​≡b1​(modm),a2​≡b2​(modm),⋯,at​≡bt​(modm),t≥2,则: ∑i=1tai≡∑i=1tbi(modm)\\sum\\limits_{i=1}^{t}a_i\\equiv\\sum\\limits_{i=1}^{t}b_i\\pmod{m} i=1∑t​ai​≡i=1∑t​bi​(modm) ∏i=1tai≡∏i=1tbi(modm)\\prod\\limits_{i=1}^{t}a_i\\equiv\\prod\\limits_{i=1}^{t}b_i\\pmod{m} i=1∏t​ai​≡i=1∏t​bi​(modm) 若 a≡b(modm)a\\equiv b\\pmod{m}a≡b(modm),则: at≡bt(modm),∀t∈Z≥1a^t\\equiv b^t\\pmod{m},\\forall t\\in \\mathbb{Z}\\ge 1 at≡bt(modm),∀t∈Z≥1 设 f(x)=∑i=0naixi∈Z⌊x⌋f(x)=\\sum\\limits_{i=0}^{n}a_ix^i\\in \\mathbb{Z}\\left\\lfloor x\\right\\rfloorf(x)=i=0∑n​ai​xi∈Z⌊x⌋ 且 an≠0a_n\\ne 0an​​=0,若 a≡b(modm)a\\equiv b\\pmod{m}a≡b(modm),那么: f(a)≡f(b)(modm)f(a)\\equiv f(b)\\pmod{m} f(a)≡f(b)(modm) 设 a,b,ca,b,ca,b,c 均为正整数,在以下的三个数中至少有一个不是平方数:a2bc+2a^2bc+2a2bc+2,b2ac+2b^2ac+2b2ac+2,c2ab+1c^2ab+1c2ab+1 证明: 反证法,假如结论不对,那么三个数均为平方数,不妨设 {a2bc+2=x2b2ac+2=y2c2ab+2=z2\\begin{cases}a^2bc+2=x^2\\\\b^2ac+2=y^2\\\\c^2ab+2=z^2\\end{cases}⎩⎪⎨⎪⎧​a2bc+2=x2b2ac+2=y2c2ab+2=z2​ 分类讨论: 若 a,b,ca,b,ca,b,c 中有偶数,不妨设 2∣a2\\mid a2∣a,那么 x2=a2bc+2≡2(mod4)x^2=a^2bc+2\\equiv 2\\pmod{4}x2=a2bc+2≡2(mod4),矛盾 若 a,b,ca,b,ca,b,c 均为奇数,则 a,b,c≡±1(mod4)a,b,c\\equiv \\pm1\\pmod{4}a,b,c≡±1(mod4),由抽屉原理,存在两数模 444 同余,不妨设 a≡b(mod4)a\\equiv b\\pmod{4}a≡b(mod4),则 ab≡1(mod4)ab\\equiv 1\\pmod{4}ab≡1(mod4),矛盾 综上所述,结论成立 Fermat 小定理 设 ppp 为素数,a∈Za\\in \\mathbb{Z}a∈Z 且 (a,p)=1(a,p)=1(a,p)=1,则 ap−1≡1(modp)a^{p-1}\\equiv 1\\pmod{p}ap−1≡1(modp) 证明: 考虑以下的 p−1p-1p−1 个数,1,2,⋯ ,p−11,2,\\cdots,p-11,2,⋯,p−1 将这 p−1p-1p−1 个数均乘 aaa,得 a,2a,⋯ ,a(p−1)a,2a,\\cdots,a(p-1)a,2a,⋯,a(p−1) 该式中的数均不是 ppp 的倍数,而且这 p−1p-1p−1 个数模 ppp 互不同余,理由如下: 若 ai≡aj(modp)ai\\equiv aj\\pmod{p}ai≡aj(modp),其中 1≤i,j≤p−11\\le i,j\\le p-11≤i,j≤p−1,因为 (a,p)=1(a,p)=1(a,p)=1,所以 i≡j(modp)i\\equiv j\\pmod{p}i≡j(modp),即得 p∣i−jp\\mid i-jp∣i−j 又 −(p−2)=1−(p−1)≤i−j≤(p−1)−1=p−2-(p-2)=1-(p-1)\\le i-j\\le (p-1)-1=p-2−(p−2)=1−(p−1)≤i−j≤(p−1)−1=p−2,即 ∣i−j∣≤p−2|i-j|\\le p-2∣i−j∣≤p−2,因此 i−j=0i-j=0i−j=0,即 i=ji=ji=j 不妨设 aiaiai 除以 ppp 的余数为 rir_iri​,那么 1≤ri≤p−11\\le r_i\\le p-11≤ri​≤p−1,因此 ai≡ri(modp),i=1,2,⋯ ,p−1ai\\equiv r_i\\pmod{p},i=1,2,\\cdots,p-1ai≡ri​(modp),i=1,2,⋯,p−1 因此,ap−1(p−1)!≡∏i=1p−1ri(modp)a^{p-1}(p-1)!\\equiv \\prod\\limits_{i=1}^{p-1}r_i\\pmod{p}ap−1(p−1)!≡i=1∏p−1​ri​(modp) 又因为 (p−1)!≡∏i=1p−1ri(modp)(p-1)!\\equiv \\prod\\limits_{i=1}^{p-1}r_i\\pmod{p}(p−1)!≡i=1∏p−1​ri​(modp) 所以 (p,(p−1)!)=1(p,(p-1)!)=1(p,(p−1)!)=1,那么: ap−1≡1(modp)a^{p-1}\\equiv 1\\pmod{p} ap−1≡1(modp) 注记: 设 ppp 为素数,a∈Za\\in \\mathbb{Z}a∈Z 且 (a,p)=1(a,p)=1(a,p)=1,则 ap−1≡1(modp)a^{p-1}\\equiv 1\\pmod{p}ap−1≡1(modp) 设 ppp 为素数,a∈Za\\in \\mathbb{Z}a∈Z,则ap≡a(modp)a^p\\equiv a\\pmod{p}ap≡a(modp) 设 ppp 为素数,a∈Za\\in \\mathbb{Z}a∈Z,则 ap−1≡0,1(modp)a^{p-1}\\equiv 0,1\\pmod{p}ap−1≡0,1(modp) ","link":"https://20170952.github.io/Yxtbs.github.io/post/chu-deng-shu-lun-zheng-li/"},{"title":"关于我","content":"Who am I? Where am I? What am I doing? 我，坐标 (ZJ,NB)\\texttt{(ZJ,NB)}(ZJ,NB)，现在是一名初二的学生。 曾经的博客在这里。 现在的博客在这里。 兴趣爱好广泛，是一个喜欢搞文化课和其他竞赛的 OIer\\texttt{OIer}OIer。 现在的水平大概是 TG\\texttt{TG}TG 组。 希望大家能多多指教~~ ","link":"https://20170952.github.io/Yxtbs.github.io/post/guan-yu-wo/"}]}